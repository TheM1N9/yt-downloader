// Server-only caption utilities (uses yt-dlp CLI)
import { execSync } from "child_process"
import { existsSync, mkdtempSync, readFileSync, readdirSync, rmSync } from "fs"
import { join } from "path"
import { tmpdir } from "os"
import type { CaptionTrack } from "./caption"

function getYtDlpPath(): string {
  const paths = [
    join(process.env.HOME || "", ".local/bin/yt-dlp"),
    "/usr/local/bin/yt-dlp",
    "/opt/homebrew/bin/yt-dlp",
    "yt-dlp",
  ]
  for (const p of paths) {
    if (p === "yt-dlp" || existsSync(p)) return p
  }
  return "yt-dlp"
}

const YT_DLP_PATH = getYtDlpPath()

export async function getCaptionTracks(videoId: string): Promise<CaptionTrack[]> {
  const url = `https://www.youtube.com/watch?v=${videoId}`

  try {
    const output = execSync([YT_DLP_PATH, "--no-warnings", "--no-playlist", "-j", url].join(" "), {
      encoding: "utf-8",
      maxBuffer: 50 * 1024 * 1024,
    })

    const info = JSON.parse(output)
    const subtitles = info.subtitles || {}
    const automaticCaptions = info.automatic_captions || {}

    const tracks: CaptionTrack[] = []

    // Manual subtitles
    for (const [langCode, formats] of Object.entries(subtitles)) {
      const vttFormat = (formats as any[]).find((f) => f.ext === "vtt" || f.ext === "srv3")
      if (vttFormat) {
        tracks.push({
          languageCode: langCode,
          languageName: vttFormat.name || langCode,
          isAutoGenerated: false,
          baseUrl: vttFormat.url,
        })
      }
    }

    // Auto-generated captions
    for (const [langCode, formats] of Object.entries(automaticCaptions)) {
      const vttFormat = (formats as any[]).find((f) => f.ext === "vtt" || f.ext === "srv3")
      if (vttFormat) {
        tracks.push({
          languageCode: langCode,
          languageName: vttFormat.name || langCode,
          isAutoGenerated: true,
          baseUrl: vttFormat.url,
        })
      }
    }

    return tracks
  } catch (error) {
    console.error("Failed to get caption tracks:", error)
    return []
  }
}

/** Fetch caption content via yt-dlp (avoids YouTube timedtext rate limits). Returns VTT string. */
export function getCaptionContentViaYtDlp(
  videoId: string,
  langCode: string
): string {
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`
  const tmpDir = mkdtempSync(join(tmpdir(), "ytcap-"))
  try {
    // Download all subs (no --sub-langs) so yt-dlp writes sub.<lang>.vtt for each;
    // then pick the file matching langCode (e.g. en-orig, ab)
    execSync(
      [
        YT_DLP_PATH,
        "--no-warnings",
        "--no-playlist",
        "--skip-download",
        "--write-subs",
        "--write-auto-subs",
        "--sub-format",
        "vtt",
        "-o",
        join(tmpDir, "sub"),
        videoUrl,
      ].join(" "),
      { encoding: "utf-8", maxBuffer: 10 * 1024 * 1024 }
    )
    const files = readdirSync(tmpDir).filter((f) => f.endsWith(".vtt"))
    // yt-dlp names files as sub.<lang>.vtt (e.g. sub.en-orig.vtt, sub.en.vtt)
    const vttFile = files.find((f) => f === `sub.${langCode}.vtt`)
      ?? files.find((f) => f.startsWith(`sub.${langCode}.`))
      ?? files[0]
    if (!vttFile) {
      throw new Error(`No VTT subtitle for lang ${langCode}`)
    }
    return readFileSync(join(tmpDir, vttFile), "utf-8")
  } finally {
    rmSync(tmpDir, { recursive: true, force: true })
  }
}
