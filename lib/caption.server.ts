// Server-only caption utilities (uses yt-dlp CLI)
import { mkdtempSync, readFileSync, readdirSync, rmSync } from "fs"
import { join } from "path"
import { tmpdir } from "os"
import type { CaptionTrack } from "./caption"
import {
  YT_DLP_PATH,
  execYtDlpJsonCached,
  execAsync,
  videoInfoCache,
} from "./yt-dlp"

export async function getCaptionTracks(videoId: string): Promise<CaptionTrack[]> {
  const url = `https://www.youtube.com/watch?v=${videoId}`
  const cacheKey = `yt:info:${videoId}`

  try {
    // Use cached video info if available (same data source as getVideoInfo)
    const info = await execYtDlpJsonCached(url, cacheKey)

    const subtitles = (info.subtitles as Record<string, unknown[]>) || {}
    const automaticCaptions =
      (info.automatic_captions as Record<string, unknown[]>) || {}

    const tracks: CaptionTrack[] = []

    // Manual subtitles
    for (const [langCode, formats] of Object.entries(subtitles)) {
      const vttFormat = (formats as { ext?: string; name?: string; url?: string }[]).find(
        (f) => f.ext === "vtt" || f.ext === "srv3"
      )
      if (vttFormat) {
        tracks.push({
          languageCode: langCode,
          languageName: vttFormat.name || langCode,
          isAutoGenerated: false,
          baseUrl: vttFormat.url || "",
        })
      }
    }

    // Auto-generated captions
    for (const [langCode, formats] of Object.entries(automaticCaptions)) {
      const vttFormat = (formats as { ext?: string; name?: string; url?: string }[]).find(
        (f) => f.ext === "vtt" || f.ext === "srv3"
      )
      if (vttFormat) {
        tracks.push({
          languageCode: langCode,
          languageName: vttFormat.name || langCode,
          isAutoGenerated: true,
          baseUrl: vttFormat.url || "",
        })
      }
    }

    return tracks
  } catch (error) {
    console.error("Failed to get caption tracks:", error)
    return []
  }
}

/** Fetch caption content via yt-dlp (avoids YouTube timedtext rate limits). Returns VTT string. */
export async function getCaptionContentViaYtDlp(
  videoId: string,
  langCode: string
): Promise<string> {
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`
  const tmpDir = mkdtempSync(join(tmpdir(), "ytcap-"))

  try {
    // Download all subs (no --sub-langs) so yt-dlp writes sub.<lang>.vtt for each;
    // then pick the file matching langCode (e.g. en-orig, ab)
    const args = [
      "--no-warnings",
      "--no-playlist",
      "--skip-download",
      "--write-subs",
      "--write-auto-subs",
      "--sub-format",
      "vtt",
      "-o",
      join(tmpDir, "sub"),
      videoUrl,
    ]

    const result = await execAsync(YT_DLP_PATH, args)

    if (result.exitCode !== 0) {
      throw new Error(`yt-dlp failed: ${result.stderr}`)
    }

    const files = readdirSync(tmpDir).filter((f) => f.endsWith(".vtt"))

    // yt-dlp names files as sub.<lang>.vtt (e.g. sub.en-orig.vtt, sub.en.vtt)
    const vttFile =
      files.find((f) => f === `sub.${langCode}.vtt`) ??
      files.find((f) => f.startsWith(`sub.${langCode}.`)) ??
      files[0]

    if (!vttFile) {
      throw new Error(`No VTT subtitle for lang ${langCode}`)
    }

    return readFileSync(join(tmpDir, vttFile), "utf-8")
  } finally {
    rmSync(tmpDir, { recursive: true, force: true })
  }
}
