// Client-safe caption utilities (no Node.js dependencies)

export interface CaptionTrack {
  languageCode: string
  languageName: string
  isAutoGenerated: boolean
  baseUrl: string
}

export interface CaptionEntry {
  start: number
  duration: number
  text: string
}

export const CAPTION_FORMATS = ["srt", "vtt", "txt"] as const
export type CaptionFormat = (typeof CAPTION_FORMATS)[number]

export function parseCaptionXml(xml: string): CaptionEntry[] {
  const entries: CaptionEntry[] = []
  
  // Parse XML manually (simple regex approach for YouTube's format)
  const textRegex = /<text start="([^"]+)" dur="([^"]+)"[^>]*>([^<]*)<\/text>/g
  let match

  while ((match = textRegex.exec(xml)) !== null) {
    const start = parseFloat(match[1])
    const duration = parseFloat(match[2])
    const text = decodeHtmlEntities(match[3])
      .replace(/\n/g, " ")
      .trim()

    if (text) {
      entries.push({ start, duration, text })
    }
  }

  return entries
}

function decodeHtmlEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#(\d+);/g, (_, num) => String.fromCharCode(parseInt(num, 10)))
}

export function formatTimestamp(seconds: number, format: "srt" | "vtt"): string {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = Math.floor(seconds % 60)
  const ms = Math.round((seconds % 1) * 1000)

  const separator = format === "srt" ? "," : "."

  return `${hours.toString().padStart(2, "0")}:${minutes
    .toString()
    .padStart(2, "0")}:${secs.toString().padStart(2, "0")}${separator}${ms
    .toString()
    .padStart(3, "0")}`
}

export function convertToSrt(entries: CaptionEntry[]): string {
  return entries
    .map((entry, index) => {
      const startTime = formatTimestamp(entry.start, "srt")
      const endTime = formatTimestamp(entry.start + entry.duration, "srt")
      return `${index + 1}\n${startTime} --> ${endTime}\n${entry.text}\n`
    })
    .join("\n")
}

export function convertToVtt(entries: CaptionEntry[]): string {
  const header = "WEBVTT\n\n"
  const body = entries
    .map((entry) => {
      const startTime = formatTimestamp(entry.start, "vtt")
      const endTime = formatTimestamp(entry.start + entry.duration, "vtt")
      return `${startTime} --> ${endTime}\n${entry.text}\n`
    })
    .join("\n")

  return header + body
}

export function convertToTxt(entries: CaptionEntry[]): string {
  return entries.map((entry) => entry.text).join("\n")
}

export function convertCaptions(
  entries: CaptionEntry[],
  format: CaptionFormat
): string {
  switch (format) {
    case "srt":
      return convertToSrt(entries)
    case "vtt":
      return convertToVtt(entries)
    case "txt":
      return convertToTxt(entries)
    default:
      throw new Error(`Unsupported format: ${format}`)
  }
}
