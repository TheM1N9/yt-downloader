// Client-safe caption utilities (no Node.js dependencies)

export interface CaptionTrack {
  languageCode: string
  languageName: string
  isAutoGenerated: boolean
  baseUrl: string
}

/** Prefer English (manual first, then auto), else first track. */
export function pickPreferredTrack(tracks: CaptionTrack[]): CaptionTrack {
  if (tracks.length === 0) throw new Error("No tracks")
  const isEn = (t: CaptionTrack) =>
    t.languageCode.toLowerCase().startsWith("en")
  const manualEn = tracks.find((t) => isEn(t) && !t.isAutoGenerated)
  if (manualEn) return manualEn
  const autoEn = tracks.find((t) => isEn(t) && t.isAutoGenerated)
  if (autoEn) return autoEn
  return tracks[0]
}

export interface CaptionEntry {
  start: number
  duration: number
  text: string
}

export const CAPTION_FORMATS = ["srt", "vtt", "txt"] as const
export type CaptionFormat = (typeof CAPTION_FORMATS)[number]

/** Parse WEBVTT content into caption entries (used when fetching via yt-dlp). */
export function parseVtt(vtt: string): CaptionEntry[] {
  const entries: CaptionEntry[] = []
  // HH:MM:SS.mmm or MM:SS.mmm --> same
  const timeRegex =
    /^(\d{2}):(\d{2}):?(\d{2})?\.(\d{3})\s*-->\s*(\d{2}):(\d{2}):?(\d{2})?\.(\d{3})/
  const toSec = (a: number, b: number, c: number | undefined, ms: number) =>
    c !== undefined
      ? a * 3600 + b * 60 + c + ms / 1000
      : a * 60 + b + ms / 1000
  const lines = vtt.split(/\r?\n/)
  let i = 0
  while (i < lines.length) {
    const match = lines[i].match(timeRegex)
    if (match) {
      const c1 = match[3] !== undefined ? parseInt(match[3], 10) : undefined
      const c2 = match[7] !== undefined ? parseInt(match[7], 10) : undefined
      const start = toSec(
        parseInt(match[1], 10),
        parseInt(match[2], 10),
        c1,
        parseInt(match[4], 10)
      )
      const end = toSec(
        parseInt(match[5], 10),
        parseInt(match[6], 10),
        c2,
        parseInt(match[8], 10)
      )
      const textLines: string[] = []
      i += 1
      while (i < lines.length && lines[i].trim() !== "") {
        textLines.push(lines[i].trim())
        i += 1
      }
      const text = cleanCaptionText(textLines.join(" ").trim())
      if (text) {
        entries.push({ start, duration: end - start, text })
      }
    }
    i += 1
  }
  return entries
}

export function parseCaptionXml(xml: string): CaptionEntry[] {
  const entries: CaptionEntry[] = []
  
  // Parse XML manually (simple regex approach for YouTube's format)
  const textRegex = /<text start="([^"]+)" dur="([^"]+)"[^>]*>([^<]*)<\/text>/g
  let match

  while ((match = textRegex.exec(xml)) !== null) {
    const start = parseFloat(match[1])
    const duration = parseFloat(match[2])
    const text = cleanCaptionText(
      decodeHtmlEntities(match[3]).replace(/\n/g, " ").trim()
    )

    if (text) {
      entries.push({ start, duration, text })
    }
  }

  return entries
}

/** Remove &nbsp; and Unicode non-breaking space from caption text. */
function cleanCaptionText(text: string): string {
  return text.replace(/\u00A0/g, " ").replace(/&nbsp;/gi, " ")
}

function decodeHtmlEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#(\d+);/g, (_, num) => String.fromCharCode(parseInt(num, 10)))
}

export function formatTimestamp(seconds: number, format: "srt" | "vtt"): string {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = Math.floor(seconds % 60)
  const ms = Math.round((seconds % 1) * 1000)

  const separator = format === "srt" ? "," : "."

  return `${hours.toString().padStart(2, "0")}:${minutes
    .toString()
    .padStart(2, "0")}:${secs.toString().padStart(2, "0")}${separator}${ms
    .toString()
    .padStart(3, "0")}`
}

export function convertToSrt(entries: CaptionEntry[]): string {
  return entries
    .map((entry, index) => {
      const startTime = formatTimestamp(entry.start, "srt")
      const endTime = formatTimestamp(entry.start + entry.duration, "srt")
      return `${index + 1}\n${startTime} --> ${endTime}\n${entry.text}\n`
    })
    .join("\n")
}

export function convertToVtt(entries: CaptionEntry[]): string {
  const header = "WEBVTT\n\n"
  const body = entries
    .map((entry) => {
      const startTime = formatTimestamp(entry.start, "vtt")
      const endTime = formatTimestamp(entry.start + entry.duration, "vtt")
      return `${startTime} --> ${endTime}\n${entry.text}\n`
    })
    .join("\n")

  return header + body
}

export function convertToTxt(entries: CaptionEntry[]): string {
  return entries.map((entry) => entry.text).join("\n")
}

export function convertCaptions(
  entries: CaptionEntry[],
  format: CaptionFormat
): string {
  switch (format) {
    case "srt":
      return convertToSrt(entries)
    case "vtt":
      return convertToVtt(entries)
    case "txt":
      return convertToTxt(entries)
    default:
      throw new Error(`Unsupported format: ${format}`)
  }
}
